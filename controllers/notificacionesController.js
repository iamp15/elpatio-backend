const Notificacion = require("../models/Notificacion");
const { registrarLog } = require("../utils/logHelper");

/**
 * Obtener notificaciones de un destinatario
 * @param {String} destinatarioId - ID del destinatario
 * @param {String} destinatarioTipo - Tipo: 'cajero' o 'jugador'
 * @param {Number} limit - Cantidad m√°xima de notificaciones (default: 10)
 */
exports.obtenerNotificaciones = async (req, res) => {
  try {
    const { destinatarioId, destinatarioTipo } = req.query;
    const limit = parseInt(req.query.limit) || 10;

    if (!destinatarioId || !destinatarioTipo) {
      return res.status(400).json({
        mensaje: "Se requiere destinatarioId y destinatarioTipo",
      });
    }

    if (!["cajero", "jugador"].includes(destinatarioTipo)) {
      return res.status(400).json({
        mensaje: "destinatarioTipo debe ser 'cajero' o 'jugador'",
      });
    }

    const notificaciones = await Notificacion.find({
      destinatarioId,
      destinatarioTipo,
    })
      .sort({ createdAt: -1 })
      .limit(limit)
      .lean();

    return res.status(200).json({
      mensaje: "Notificaciones obtenidas exitosamente",
      notificaciones,
      total: notificaciones.length,
    });
  } catch (error) {
    console.error("‚ùå Error obteniendo notificaciones:", error);
    return res.status(500).json({
      mensaje: "Error obteniendo notificaciones",
      error: error.message,
    });
  }
};

/**
 * Obtener notificaciones de un jugador por telegramId
 */
exports.obtenerNotificacionesJugador = async (req, res) => {
  try {
    const { telegramId } = req.params;
    const limit = parseInt(req.query.limit) || 10;

    if (!telegramId) {
      return res.status(400).json({
        mensaje: "Se requiere telegramId",
      });
    }

    const notificaciones = await Notificacion.find({
      telegramId,
      destinatarioTipo: "jugador",
    })
      .sort({ createdAt: -1 })
      .limit(limit)
      .lean();

    return res.status(200).json({
      mensaje: "Notificaciones obtenidas exitosamente",
      notificaciones,
      total: notificaciones.length,
    });
  } catch (error) {
    console.error(
      "‚ùå Error obteniendo notificaciones de jugador:",
      error.message
    );
    return res.status(500).json({
      mensaje: "Error obteniendo notificaciones",
      error: error.message,
    });
  }
};

/**
 * Crear una notificaci√≥n
 * Verifica duplicados por eventoId si est√° presente
 */
exports.crearNotificacion = async (req, res) => {
  try {
    const {
      destinatarioId,
      destinatarioTipo,
      telegramId,
      tipo,
      titulo,
      mensaje,
      datos,
      eventoId,
    } = req.body;

    // Validaciones
    if (!destinatarioId || !destinatarioTipo || !tipo || !titulo || !mensaje) {
      return res.status(400).json({
        mensaje:
          "Se requiere destinatarioId, destinatarioTipo, tipo, titulo y mensaje",
      });
    }

    // Verificar duplicados por eventoId
    if (eventoId) {
      const existente = await Notificacion.findOne({ eventoId });
      if (existente) {
        console.log(
          `‚ö†Ô∏è Notificaci√≥n duplicada detectada para eventoId: ${eventoId}`
        );
        return res.status(200).json({
          mensaje: "Notificaci√≥n ya existe",
          notificacion: existente,
          duplicada: true,
        });
      }
    }

    // Crear notificaci√≥n
    const notificacion = new Notificacion({
      destinatarioId,
      destinatarioTipo,
      telegramId,
      tipo,
      titulo,
      mensaje,
      datos: datos || {},
      eventoId,
    });

    await notificacion.save();

    console.log(
      `‚úÖ Notificaci√≥n creada: ${tipo} para ${destinatarioTipo} ${destinatarioId}`
    );

    return res.status(201).json({
      mensaje: "Notificaci√≥n creada exitosamente",
      notificacion,
    });
  } catch (error) {
    console.error("‚ùå Error creando notificaci√≥n:", error.message);
    return res.status(500).json({
      mensaje: "Error creando notificaci√≥n",
      error: error.message,
    });
  }
};

/**
 * Crear notificaci√≥n (funci√≥n interna para usar en el backend)
 * No requiere req/res, retorna la notificaci√≥n o null si hay error
 */
exports.crearNotificacionInterna = async (data) => {
  try {
    const {
      destinatarioId,
      destinatarioTipo,
      telegramId,
      tipo,
      titulo,
      mensaje,
      datos,
      eventoId,
    } = data;

    // Validaciones b√°sicas
    if (!destinatarioId || !destinatarioTipo || !tipo || !titulo || !mensaje) {
      console.error("‚ùå Datos incompletos para crear notificaci√≥n");
      return null;
    }

    // Verificar duplicados por eventoId
    if (eventoId) {
      const existente = await Notificacion.findOne({ eventoId });
      if (existente) {
        console.log(
          `‚ö†Ô∏è Notificaci√≥n duplicada detectada para eventoId: ${eventoId}`
        );
        return existente;
      }
    }

    // Crear notificaci√≥n
    const notificacion = new Notificacion({
      destinatarioId,
      destinatarioTipo,
      telegramId,
      tipo,
      titulo,
      mensaje,
      datos: datos || {},
      eventoId,
    });

    await notificacion.save();

    console.log(
      `‚úÖ Notificaci√≥n creada: ${tipo} para ${destinatarioTipo} ${destinatarioId}`
    );

    return notificacion;
  } catch (error) {
    console.error("‚ùå Error creando notificaci√≥n interna:", error.message);
    return null;
  }
};

/**
 * Eliminar una notificaci√≥n por ID
 */
exports.eliminarNotificacion = async (req, res) => {
  try {
    const { id } = req.params;

    if (!id) {
      return res.status(400).json({
        mensaje: "Se requiere ID de notificaci√≥n",
      });
    }

    const notificacion = await Notificacion.findByIdAndDelete(id);

    if (!notificacion) {
      return res.status(404).json({
        mensaje: "Notificaci√≥n no encontrada",
      });
    }

    console.log(`üóëÔ∏è Notificaci√≥n eliminada: ${id}`);

    return res.status(200).json({
      mensaje: "Notificaci√≥n eliminada exitosamente",
      notificacion,
    });
  } catch (error) {
    console.error("‚ùå Error eliminando notificaci√≥n:", error.message);
    return res.status(500).json({
      mensaje: "Error eliminando notificaci√≥n",
      error: error.message,
    });
  }
};

/**
 * Limpiar notificaciones antiguas
 * Elimina notificaciones con m√°s de X d√≠as de antig√ºedad
 * @param {Number} dias - N√∫mero de d√≠as (default: 7)
 */
exports.limpiarNotificacionesAntiguas = async (dias = 7) => {
  try {
    const fechaLimite = new Date();
    fechaLimite.setDate(fechaLimite.getDate() - dias);

    const resultado = await Notificacion.deleteMany({
      createdAt: { $lt: fechaLimite },
    });

    console.log(
      `üßπ Limpieza de notificaciones completada: ${resultado.deletedCount} notificaciones eliminadas (m√°s de ${dias} d√≠as)`
    );

    // Registrar en logs
    await registrarLog({
      tipo: "sistema",
      accion: "limpieza_notificaciones",
      detalles: `Eliminadas ${resultado.deletedCount} notificaciones con m√°s de ${dias} d√≠as`,
      resultado: "exitoso",
    });

    return {
      eliminadas: resultado.deletedCount,
      diasAntiguedad: dias,
      fechaLimite,
    };
  } catch (error) {
    console.error("‚ùå Error limpiando notificaciones antiguas:", error.message);

    // Registrar error en logs
    await registrarLog({
      tipo: "sistema",
      accion: "limpieza_notificaciones",
      detalles: `Error: ${error.message}`,
      resultado: "error",
    });

    return null;
  }
};

/**
 * Endpoint para ejecutar limpieza manual
 */
exports.ejecutarLimpieza = async (req, res) => {
  try {
    const dias = parseInt(req.query.dias) || 7;
    const resultado = await exports.limpiarNotificacionesAntiguas(dias);

    if (resultado) {
      return res.status(200).json({
        mensaje: "Limpieza ejecutada exitosamente",
        ...resultado,
      });
    } else {
      return res.status(500).json({
        mensaje: "Error ejecutando limpieza",
      });
    }
  } catch (error) {
    console.error("‚ùå Error en endpoint de limpieza:", error.message);
    return res.status(500).json({
      mensaje: "Error ejecutando limpieza",
      error: error.message,
    });
  }
};
