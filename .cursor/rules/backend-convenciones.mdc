---
description: Convenciones y estÃ¡ndares especÃ­ficos para el backend de El Patio
globs: ["elpatio-backend/**/*.js"]
alwaysApply: false
---

# Backend - El Patio - Convenciones y EstÃ¡ndares

##Estado del backend
- El proyecto se encuentra en modo de desarrollo, no obstante, el backend esta corriendo en una VM de fly.io.
- Todas las pruebas se hacen con el servidor live, no se hacen en local.


## ğŸ“‹ Estructura del MÃ³dulo

El backend sigue una arquitectura MVC con Express.js y MongoDB:

```
elpatio-backend/
â”œâ”€â”€ app.js                  # ConfiguraciÃ³n de Express y middleware
â”œâ”€â”€ server.js               # Punto de entrada e inicializaciÃ³n del servidor
â”œâ”€â”€ config/                 # Configuraciones (DB, roles, etc.)
â”œâ”€â”€ routes/                 # DefiniciÃ³n de rutas (solo routing, sin lÃ³gica)
â”œâ”€â”€ controllers/            # LÃ³gica de negocio y manejo de requests
â”œâ”€â”€ models/                 # Modelos de Mongoose
â”œâ”€â”€ middlewares/            # Middlewares personalizados
â”œâ”€â”€ websocket/              # GestiÃ³n de WebSockets
â””â”€â”€ utils/                  # Utilidades y helpers
```

## ğŸ›£ï¸ Rutas (routes/)

### Estructura de Archivos de Rutas

- Un archivo por recurso (ej: `jugadores.js`, `salas.js`, `transacciones.js`)
- Usar Express Router
- Solo definir rutas y middlewares, sin lÃ³gica de negocio
- Importar controllers usando destructuring cuando hay mÃºltiples funciones
- Comentarios descriptivos en espaÃ±ol para cada ruta

### Patrones de Rutas

```javascript
const express = require("express");
const router = express.Router();
const {
  crearJugador,
  obtenerJugadores,
  obtenerJugadorPorId,
} = require("../controllers/jugadoresController");
const auth = require("../middlewares/auth");
const verificarMinimo = require("../middlewares/verificarMinimo");

// Ruta con comentario descriptivo
router.post("/", auth, verificarMinimo("bot"), crearJugador);
router.get("/", auth, verificarMinimo("bot"), obtenerJugadores);
router.get("/:id", auth, verificarMinimo("bot"), obtenerJugadorPorId);

module.exports = router;
```

### Convenciones de Nombres de Rutas

- Usar kebab-case para parÃ¡metros en URLs: `/:telegramId`, `/:transaccionId`
- Rutas especÃ­ficas antes de rutas genÃ©ricas (ej: `/check-nickname/:nickname` antes de `/:telegramId`)
- Agrupar rutas relacionadas: `/:telegramId/saldo/acreditar`
- Usar verbos HTTP apropiados:
  - `GET` para obtener/leer
  - `POST` para crear
  - `PUT` para actualizar completo
  - `PATCH` para actualizaciones parciales (si se usa)
  - `DELETE` para eliminar

## ğŸ® Controllers

### Estructura de Controllers

- Usar `exports.functionName` en lugar de `module.exports = { ... }`
- Funciones async/await (nunca Promises.then())
- Try-catch en todas las funciones async
- Nombres de funciones descriptivos en espaÃ±ol (camelCase)
- Una funciÃ³n por operaciÃ³n (ej: `crearJugador`, `obtenerJugadores`, `actualizarJugador`)

### PatrÃ³n de Controller

```javascript
const Model = require("../models/Model");

exports.crearRecurso = async (req, res) => {
  try {
    // ValidaciÃ³n de entrada
    const { campo1, campo2 } = req.body;
    
    if (!campo1) {
      return res.status(400).json({
        error: "Campo requerido",
        code: "CAMPO_REQUERIDO",
      });
    }

    // LÃ³gica de negocio
    const nuevoRecurso = new Model({ campo1, campo2 });
    await nuevoRecurso.save();

    // Respuesta exitosa
    res.status(201).json({
      message: "Recurso creado correctamente",
      recurso: nuevoRecurso,
    });
  } catch (error) {
    console.error("Error creando recurso:", error);
    
    // Manejo especÃ­fico de errores
    if (error.code === 11000) {
      return res.status(409).json({
        error: "Recurso duplicado",
        code: "DUPLICADO",
      });
    }

    res.status(500).json({
      error: "Error interno del servidor",
      message: error.message,
    });
  }
};
```

### Convenciones de Nombres de Funciones

- `crear*` - Crear un nuevo recurso
- `obtener*` - Obtener un recurso (singular)
- `obtener*s` - Obtener mÃºltiples recursos (plural)
- `obtener*Por*` - Obtener por un campo especÃ­fico
- `actualizar*` - Actualizar un recurso
- `eliminar*` - Eliminar un recurso
- `verificar*` - Verificar algo
- `check*` - Verificar disponibilidad o existencia

### Respuestas API

- **Ã‰xito (200/201)**: `res.status(201).json({ message: "...", data: ... })`
- **Error de validaciÃ³n (400)**: `res.status(400).json({ error: "...", code: "CODIGO_ERROR" })`
- **No autorizado (401)**: `res.status(401).json({ mensaje: "Token no proporcionado" })`
- **Prohibido (403)**: `res.status(403).json({ mensaje: "Acceso denegado" })`
- **No encontrado (404)**: `res.status(404).json({ error: "...", code: "NO_ENCONTRADO" })`
- **Conflicto (409)**: `res.status(409).json({ error: "...", code: "DUPLICADO" })`
- **Error servidor (500)**: `res.status(500).json({ error: "Error interno del servidor" })`

- Incluir cÃ³digo de error cuando sea Ãºtil para el cliente
- Mensajes de error descriptivos en espaÃ±ol
- No exponer detalles internos en producciÃ³n

## ğŸ—„ï¸ Models (Mongoose)

### Estructura de Schemas

- Usar `mongoose.Schema` con objetos de configuraciÃ³n
- Especificar `collection` cuando el nombre difiere del modelo
- Campos descriptivos con tipos apropiados
- Validaciones en el schema (required, min, max, enum, etc.)
- Valores por defecto cuando sea apropiado
- Ãndices Ãºnicos para campos que deben ser Ãºnicos
- Campos de fecha con `default: Date.now` (no usar timestamps: true)

### PatrÃ³n de Model

```javascript
const mongoose = require("mongoose");

const modeloSchema = new mongoose.Schema(
  {
    campoUnico: {
      type: String,
      unique: true,
      required: true,
    },
    campoOpcional: {
      type: String,
    },
    estado: {
      type: String,
      enum: ["activo", "inactivo", "bloqueado"],
      default: "activo",
    },
    fechaCreacion: {
      type: Date,
      default: Date.now,
    },
  },
  { collection: "nombre_coleccion" }
);

module.exports = mongoose.model("Modelo", modeloSchema);
```

### Convenciones de Nombres

- Nombres de modelos en PascalCase (ej: `Jugador`, `Sala`, `Transaccion`)
- Nombres de colecciones en plural y lowercase (ej: `jugadores`, `salas`)
- Campos en camelCase (ej: `telegramId`, `fechaCreacion`, `datosBancarios`)
- Enums en lowercase con valores descriptivos en espaÃ±ol

## ğŸ” Middlewares

### Estructura de Middlewares

- Funciones simples que reciben `(req, res, next)`
- Exportar la funciÃ³n directamente o una funciÃ³n que retorna middleware
- Usar `next()` para continuar, `return res.status(...).json(...)` para detener
- Colocar informaciÃ³n en `req` para uso posterior (ej: `req.user`)

### Middlewares Existentes

- `auth.js` - VerificaciÃ³n de token JWT (coloca `req.user`)
- `verificarMinimo.js` - VerificaciÃ³n de rol mÃ­nimo (retorna funciÃ³n)
- `verificarAdmin.js` - VerificaciÃ³n de admin
- `verificarSuperadmin.js` - VerificaciÃ³n de superadmin
- `telegramAuth.js` - AutenticaciÃ³n para Telegram Web Apps
- `errorHandler.js` - Manejo global de errores (debe ser el Ãºltimo middleware)

### PatrÃ³n de Middleware

```javascript
// Middleware simple
const middleware = (req, res, next) => {
  // LÃ³gica de verificaciÃ³n
  if (!req.headers.authorization) {
    return res.status(401).json({ mensaje: "No autorizado" });
  }
  // Agregar datos a req si es necesario
  req.user = decoded;
  next();
};

module.exports = middleware;

// Middleware que retorna funciÃ³n
const middlewareFactory = (parametro) => {
  return (req, res, next) => {
    // Usar parÃ¡metro
    if (req.user.rol !== parametro) {
      return res.status(403).json({ mensaje: "Acceso denegado" });
    }
    next();
  };
};

module.exports = middlewareFactory;
```

## ğŸŒ WebSocket

### Estructura WebSocket

- `socketManager.js` - Clase principal que gestiona Socket.IO
- Managers separados por responsabilidad (rooms, conexiones, timeouts, etc.)
- Eventos descriptivos en espaÃ±ol usando kebab-case
- Manejo de desconexiones con sistema de recuperaciÃ³n
- Logs descriptivos con emojis para debugging

### Patrones WebSocket

```javascript
// En socketManager.js
class SocketManager {
  constructor() {
    this.io = null;
    this.connectedUsers = new Map();
    // Inicializar managers
  }

  initialize(server) {
    const { Server } = require("socket.io");
    this.io = new Server(server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"],
      },
    });
    this.setupEventHandlers();
  }

  setupEventHandlers() {
    this.io.on("connection", (socket) => {
      console.log(`ğŸ”— Cliente conectado: ${socket.id}`);
      
      socket.on("evento-cliente", async (data) => {
        try {
          // Manejo del evento
        } catch (error) {
          console.error("âŒ Error:", error);
          socket.emit("error", { mensaje: error.message });
        }
      });

      socket.on("disconnect", (reason) => {
        console.log(`ğŸ”Œ Cliente desconectado: ${socket.id}, razÃ³n: ${reason}`);
        this.handleDisconnect(socket);
      });
    });
  }
}
```

### Convenciones WebSocket

- Nombres de eventos en kebab-case y espaÃ±ol
- Emitir eventos de error con estructura consistente
- Manejar desconexiones gracefully
- Usar rooms para agrupar sockets relacionados
- Logs con emojis: ğŸ”— conexiÃ³n, ğŸ”Œ desconexiÃ³n, âŒ error, âœ… Ã©xito

## ğŸ”§ ConfiguraciÃ³n

### app.js

- Configurar CORS con orÃ­genes permitidos por ambiente
- Middlewares globales: cors, morgan, express.json
- Health check endpoint en `/health`
- Rutas de prueba (test-*.html) para desarrollo
- Registro de rutas API con `/api/*`
- ErrorHandler como Ãºltimo middleware

### server.js

- ConexiÃ³n a MongoDB antes de iniciar servidor
- Shutdown graceful con manejo de seÃ±ales (SIGTERM, SIGINT)
- Manejo de errores no capturados (uncaughtException, unhandledRejection)
- InicializaciÃ³n de WebSocket despuÃ©s de iniciar servidor
- InicializaciÃ³n de servicios adicionales (limpieza automÃ¡tica, configuraciones)
- Logs informativos con emojis y versiÃ³n de la aplicaciÃ³n

### Variables de Entorno

- Usar `dotenv` para cargar variables
- Validar variables crÃ­ticas al inicio
- Proporcionar valores por defecto cuando sea apropiado
- Documentar en `env.example`

## ğŸ“ Logging

- Usar `console.log` con emojis para informaciÃ³n:
  - âœ… Ã‰xito
  - âŒ Error
  - âš ï¸ Advertencia
  - ğŸ”„ Proceso
  - ğŸ›‘ DetenciÃ³n
  - ğŸ”— ConexiÃ³n
  - ğŸ”Œ DesconexiÃ³n
- Usar `console.error` para errores
- Incluir contexto relevante en logs (IDs, estados, etc.)
- En producciÃ³n, considerar sistema de logging mÃ¡s robusto

## ğŸš« Errores Comunes a Evitar

1. **No usar try-catch en funciones async** - Siempre incluir manejo de errores
2. **LÃ³gica de negocio en rutas** - Toda la lÃ³gica debe estar en controllers
3. **Validaciones solo en el cliente** - Validar tambiÃ©n en el backend
4. **Exponer detalles de error en producciÃ³n** - Usar mensajes genÃ©ricos
5. **No manejar errores de MongoDB** - Manejar cÃ³digos de error especÃ­ficos (11000 para duplicados)
6. **Rutas sin autenticaciÃ³n** - Verificar que rutas protegidas tengan middlewares de auth
7. **Nombres de funciones genÃ©ricos** - Usar nombres descriptivos y especÃ­ficos
8. **Comentarios innecesarios** - Comentar solo cuando sea necesario explicar lÃ³gica compleja

## âœ… Buenas PrÃ¡cticas

1. **ValidaciÃ³n de entrada** - Validar todos los datos de entrada
2. **CÃ³digos HTTP apropiados** - Usar cÃ³digos correctos para cada situaciÃ³n
3. **Mensajes descriptivos** - Mensajes claros para el cliente
4. **Manejo de errores especÃ­fico** - Manejar errores conocidos (duplicados, no encontrado, etc.)
5. **Transacciones atÃ³micas** - Usar transacciones de MongoDB cuando sea necesario
6. **Ãndices apropiados** - Agregar Ã­ndices para consultas frecuentes
7. **SeparaciÃ³n de responsabilidades** - Cada archivo/mÃ³dulo con una responsabilidad clara
8. **DocumentaciÃ³n** - Comentarios JSDoc para funciones complejas
